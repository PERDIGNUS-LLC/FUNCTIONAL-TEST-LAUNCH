<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TerraDignus | The NestEgg</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&family=Playfair+Display:wght@400;600&display=swap');

        body {
            margin: 0;
            background-color: #ffffff;
            font-family: 'Roboto', sans-serif;
            overflow-x: hidden;
            color: #333;
        }

        /* HEADER */
        header {
            position: absolute;
            top: 40px; left: 40px;
            z-index: 10;
        }

        .brand-name {
            font-family: 'Roboto', sans-serif;
            font-weight: 700;
            font-size: 24px;
            color: #2C3E50;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* VIEWPORT */
        #viewport {
            position: relative;
            width: 100%;
            height: 85vh;
            background: #ffffff;
            overflow: hidden;
            cursor: default;
        }

        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        /* SVG LINES */
        polyline {
            fill: none;
            stroke: #333;
            stroke-width: 1;
            vector-effect: non-scaling-stroke;
        }

        /* DOTS (The anchor points on the model) */
        .hotspot-dot {
            position: absolute;
            width: 12px; height: 12px;
            border-radius: 50%;
            border: 1.5px solid #333;
            background: rgba(255,255,255,0.5);
            transform: translate(-50%, -50%);
            cursor: pointer;
            z-index: 10;
            transition: transform 0.2s, background-color 0.2s;
            pointer-events: auto;
        }

        .hotspot-dot:hover {
            transform: translate(-50%, -50%) scale(1.5);
            background-color: #333;
        }

        /* FLOATING LABELS (Engineering Style) */
        .floating-label {
            position: absolute;
            font-family: 'Roboto', sans-serif;
            font-size: 13px;
            font-weight: 500;
            color: #000;
            /* Underline style like the engineering drawing */
            border-bottom: 1px solid #333;
            padding-bottom: 2px;
            white-space: nowrap;
            pointer-events: none;
            z-index: 6;
            transition: opacity 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* DETAILED INFO BOX (Appears on Click) */
        .label-text {
            position: absolute;
            font-family: 'Times New Roman', serif;
            font-size: 18px;
            color: #000;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            z-index: 20;
            text-decoration: underline;
            text-underline-offset: 4px;
        }

        .desc-text {
            display: block;
            font-family: 'Roboto', sans-serif;
            font-size: 14px;
            color: #555;
            margin-top: 4px;
            max-width: 250px;
            white-space: normal;
            line-height: 1.4;
            text-decoration: none;
        }

        /* FOOTER */
        .footer-ip {
            background-color: #EBEBEB;
            padding: 50px 20px;
            text-align: center;
        }
        .footer-ip h3 { font-size: 20px; margin-bottom: 10px; font-weight: 700; }
        .footer-ip p { font-size: 16px; margin: 0 0 25px 0; }
        .patent-list { font-family: 'Courier New', monospace; font-size: 13px; line-height: 1.8; }

        .footer-brand {
            background-color: #080808;
            color: #ffffff;
            padding: 50px 20px;
            text-align: center;
        }
        .company-name { font-size: 18px; font-weight: 700; letter-spacing: 1px; }
        .sub-brand { font-family: 'Playfair Display', serif; font-size: 16px; color: #ccc; margin-bottom: 25px; }
        .copyright { font-size: 12px; color: #666; }
    </style>
   <style>
/* --- Chirp Button Styles --- */
.chirp-button {
  background: white;
  border: 2px solid #FFD700; /* Gold border */
  border-radius: 50px;       /* Pill shape */
  padding: 12px 28px;
  display: flex;
  align-items: center;
  gap: 15px;
  cursor: pointer;
  font-family: inherit;      /* Uses your site's font */
  font-weight: bold;
  color: #555;
  transition: all 0.2s ease;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
  outline: none;
}

.chirp-button:hover {
  background: #FFFDF0;       /* Very light yellow tint on hover */
  transform: translateY(-2px);
  box-shadow: 0 6px 15px rgba(0,0,0,0.1);
  border-color: #ffcc00;
}

.chirp-button:active {
  transform: scale(0.96);    /* Button presses down when clicked */
}

/* --- The Animation Logic --- */

/* Wing Animation */
.chirping #wing {
  transform-origin: 30px 50px; /* Pivot point for the wing */
  animation: flap 0.15s ease-in-out infinite alternate;
}

/* Beak Top Animation */
.chirping #beak-top {
  transform-origin: 85px 47px; /* Pivot point for top beak */
  animation: talk-top 0.1s linear infinite alternate;
}

/* Beak Bottom Animation */
.chirping #beak-bottom {
  transform-origin: 85px 57px; /* Pivot point for bottom beak */
  animation: talk-bottom 0.1s linear infinite alternate;
}

/* --- Keyframes (The Movement) --- */

@keyframes flap {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(-30deg); } /* Flap Up */
}

@keyframes talk-top {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(-20deg); } /* Open Up */
}

@keyframes talk-bottom {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(15deg); } /* Open Down */
}
   </style>
    
</head>

<body>

<header>
    <div class="brand-name">TerraDignus</div>
</header>

<div id="viewport">
    <svg id="ui-layer">
        <polyline id="active-connector" points="" style="stroke-width:2; opacity:0" />
    </svg>

    <div id="active-label" class="label-text">
        <span id="label-title"></span>
        <span id="label-desc" class="desc-text"></span>
    </div>
</div>
<div class="chirp-container" style="display: flex; justify-content: center; margin: 3rem 0;">
  
  <button id="chirp-btn" class="chirp-button" aria-label="Give a Chirp">
    
    <svg class="chick-svg" viewBox="0 0 100 100" width="45" height="45">
      <path d="M45,85 L45,9#333" stroke-width="4" stroke-linecap="round"/>
      
      <circle cx="50" cy="50" r="40" fill="#FFD700" /> 
      
      <circle cx="65" cy="40" r="4" fill="#333" />
      
      <g id="beak-group">
        <path id="beak-top" d="M85,42 L100,47 L85,52 Z" fill="#FF8C00" />
        <path id="beak-bottom" d="M85,52 L100,57 L85,62 Z" fill="#FF8C00" />
      </g>
      
      <path id="wing" d="M30,50 Q10,40 20,70 Q40,80 50,60" fill="#F4C430" stroke="#E0B120" stroke-width="2" />
    </svg>

    <div class="text-container" style="display: flex; flex-direction: column; align-items: flex-start; line-height: 1.2;">
      <span class="label">Give a Chirp</span>
      <span id="chirp-count" class="count" style="font-size: 0.8em; opacity: 0.7;">0 chirps</span>
    </div>

  </button>

  <audio id="chirp-sound" src="chirp.mp3" preload="auto"></audio>

</div>

<footer>
    <div class="footer-ip">
        <h3>Intellectual Property Portfolio</h3>
        <p>Our technology is protected by pending United States Patents.</p>
        <div class="patent-list">
            <div>USPTO PATENT PENDING: Modular Wildlife Habitation System</div>
            <div>USPTO PATENT PENDING: In-Situ Monolithic Composite System</div>
            <div>USPTO PATENT PENDING: Variable-Volume Wildlife Habitation System</div>
        </div>
    </div>

    <div class="footer-brand">
        <div class="company-name">PERDIGNUS LLC</div>
        <div class="sub-brand">TerraDignus™ | NecTerra</div>
        <div class="copyright">© MMXXV Nicholas J. Law. All Rights Reserved.</div>
    </div>
</footer>


<script>
/* ============================
   1. SCENE SETUP
============================ */
const container = document.getElementById('viewport');
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xffffff);

const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 100);
const homePos = { x: 0, y: 0, z: 10 };
camera.position.set(homePos.x, homePos.y, homePos.z);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(container.clientWidth, container.clientHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
container.appendChild(renderer.domElement);

/* ============================
   2. LIGHTING
============================ */
scene.add(new THREE.AmbientLight(0xffffff, 0.4));

const keyLight = new THREE.DirectionalLight(0xffffff, 0.55);
keyLight.position.set(4, 10, 6);
keyLight.castShadow = true;
keyLight.shadow.mapSize.width = 1024;
keyLight.shadow.mapSize.height = 1024;
scene.add(keyLight);

const fillLight = new THREE.DirectionalLight(0xffe9c9, 0.20);
fillLight.position.set(-6, 3, 4);
scene.add(fillLight);

const rimLight = new THREE.DirectionalLight(0xffffff, 0.35);
rimLight.position.set(0, 6, -6);
scene.add(rimLight);

/* ============================
   3. MATERIAL
============================ */
const cvs = document.createElement('canvas');
cvs.width = 512; cvs.height = 512;
const ctx = cvs.getContext('2d');
const imgData = ctx.createImageData(512, 512);
for (let i = 0; i < imgData.data.length; i += 4) {
    const grain = (Math.random() * 0.5 + 0.5) * 255;
    imgData.data[i] = grain;
    imgData.data[i+1] = grain;
    imgData.data[i+2] = grain;
    imgData.data[i+3] = 255;
}
ctx.putImageData(imgData, 0, 0);
const noiseTexture = new THREE.CanvasTexture(cvs);

const necterraMaterial = new THREE.MeshStandardMaterial({
    color: 0xD6C8B5,
    roughness: 0.9,
    metalness: 0.0,
    bumpMap: noiseTexture,
    bumpScale: 0.02
});

/* ============================
   4. MODEL & HIERARCHY
============================ */
function deg(d) { return d * Math.PI / 180; }

// GROUP STRUCTURE:
const turntableGroup = new THREE.Group();
scene.add(turntableGroup);

const nestEggGroup = new THREE.Group();
turntableGroup.add(nestEggGroup);

// Initial egg orientation
nestEggGroup.rotation.set(deg(90), deg(180), deg(137.5));

let eggMesh = null; // Used for occlusion raycasting

const loader = new THREE.GLTFLoader();
const dracoLoader = new THREE.DRACOLoader();
dracoLoader.setDecoderPath('https://unpkg.com/three@0.128.0/examples/js/libs/draco/');
loader.setDRACOLoader(dracoLoader);

loader.load("assets/NestEggFBCR.glb", function (gltf) {
    const model = gltf.scene;
    model.scale.set(0.65, 0.65, 0.65);

    // Center the geometry internally
    const box = new THREE.Box3().setFromObject(model);
    const center = box.getCenter(new THREE.Vector3());
    model.position.sub(center); 
    
    // Material Apply
    model.traverse((child) => {
        if (child.isMesh) {
            child.material = necterraMaterial; 
            child.castShadow = true;
            child.receiveShadow = true;
            eggMesh = child; 
        }
    });

    nestEggGroup.add(model);
    
    // Setup Annotations AFTER model is ready
    setupAnnotations(center);

}, undefined, function (err) {
    console.error("Error loading model:", err);
});


/* ============================
   5. ANNOTATION DATA
============================ */
const annotations = [
    {
        id: 1,
        title: "Ventilation",
        desc: "Passive thermal regulation vent improving internal microclimate stability.",
        pos: new THREE.Vector3(-0.922, 2.144, 0.993),
        camPos: { x: 3, y: 2, z: 5 }
    },
    {
        id: 2,
        title: "Entrance Insert",
        desc: "Interchangeable species-specific modular entrance geometry.",
        pos: new THREE.Vector3(1.561, 1.056, 1.514),
        camPos: { x: 4, y: 1.5, z: 5 }
    },
    {
        id: 3,
        title: "Shell Joint",
        desc: "Precision interface between upper and lower hemispheres.",
        pos: new THREE.Vector3(-2.292, -0.591, 0.994),
        camPos: { x: -4, y: 0.5, z: 5 }
    },
    {
        id: 4,
        title: "Drainage",
        desc: "Allows moisture to escape the basal chamber via an internal plenum system.",
        pos: new THREE.Vector3(-0.389, -3.134, 0.363),
        camPos: { x: 0, y: -6.0, z: 3 }
    },
    {
        id: 5,
        title: "Mounting",
        desc: "Integrated rear mounting surface for stable installation.",
        pos: new THREE.Vector3(0.022, -3.279, 0.772),
        camPos: { x: -3.5, y: -4, z: 2 }
    },
    {
        id: 6,
        title: "Cling Ridges",
        desc: "Exterior gripping geometry for allowing birds the functionality of texture without the inherent predatory risks of a perch.",
        pos: new THREE.Vector3(2.279, 0.131, 0.701),
        camPos: { x: 4, y: 1, z: 5 }
    },
    {
        id: 7,
        title: "Gutter Channel",
        desc: "Rain diverter channel preventing entrance flooding.",
        pos: new THREE.Vector3(0.054, -0.076, 2.412),
        camPos: { x: 0.5, y: 1.5, z: 6 }
    }
];

// Helper to create the 3D anchors, DOM Elements, and SVG Lines
const uiLayer = document.getElementById('ui-layer');

function setupAnnotations(centerOffset) {
    annotations.forEach(a => {
        // 1. Create 3D Anchor (Spins with Egg)
        const anchor = new THREE.Object3D();
        const adjustedPos = a.pos.clone().sub(centerOffset);
        
        scene.add(anchor); 
        anchor.position.copy(adjustedPos); 
        nestEggGroup.attach(anchor); 
        a.anchorObj = anchor; 

        // 2. Create Dot (The circle on the egg)
        const dot = document.createElement('div');
        dot.className = 'hotspot-dot';
        dot.addEventListener('click', e => {
            e.stopPropagation();
            activateAnnotation(a);
        });
        container.appendChild(dot);
        a.dotElement = dot;

        // 3. Create Floating Label (The text off to the side)
        const label = document.createElement('div');
        label.className = 'floating-label';
        label.innerText = a.title;
        container.appendChild(label);
        a.labelElement = label;

        // 4. Create SVG Leader Line
        const line = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
        // Initial style
        line.style.opacity = 0; 
        uiLayer.appendChild(line);
        a.lineElement = line;
    });
}


/* ============================
   6. CONTROLS & UI
============================ */
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.enableZoom = false; 
controls.enablePan = false;
controls.minPolarAngle = Math.PI / 4;
controls.maxPolarAngle = Math.PI - Math.PI / 4;

// References for the "Active" detail view
const activeConnector = document.getElementById('active-connector');
const labelDiv = document.getElementById('active-label');
const labelTitle = document.getElementById('label-title');
const labelDesc = document.getElementById('label-desc');

/* ============================
   7. INTERACTION
============================ */
let activeAnnotation = null;

function activateAnnotation(data) {
    activeAnnotation = data;

    // Pause rotation
    gsap.to(turntableGroup.rotation, {
        duration: 1.0,
        y: 0,
        ease: "power2.out"
    });

    // Move Camera
    gsap.to(camera.position, {
        duration: 1.5,
        x: data.camPos.x,
        y: data.camPos.y,
        z: data.camPos.z,
        ease: "power2.inOut"
    });

    // Populate Detail Box
    labelTitle.innerText = data.title;
    labelDesc.innerText = data.desc;

    // Show Detail Box after delay
    setTimeout(() => {
        if (activeAnnotation === data) {
            labelDiv.style.opacity = 1;
            activeConnector.style.opacity = 1;
        }
    }, 800);
}

function resetView() {
    if (!activeAnnotation) return;
    activeAnnotation = null;

    labelDiv.style.opacity = 0;
    activeConnector.style.opacity = 0;

    gsap.to(camera.position, {
        duration: 1.5,
        x: homePos.x,
        y: homePos.y,
        z: homePos.z,
        ease: "power2.inOut"
    });
}

container.addEventListener('click', resetView);


/* ============================
   8. RENDER LOOP (Anim + Occlusion + Leader Lines)
============================ */
const raycaster = new THREE.Raycaster();
const tempVec = new THREE.Vector3();

function animate() {
    requestAnimationFrame(animate);
    controls.update();

    // --- ROTATION & BOBBING ---
    if (!activeAnnotation) {
        turntableGroup.rotation.y += 0.001; 
        const time = performance.now() * 0.001;
        nestEggGroup.position.y = Math.sin(time * 1.05) * 0.20;
    } else {
        nestEggGroup.position.y = 0; 
    }

    renderer.render(scene, camera);
    updateAnnotations();
}

function updateAnnotations() {
    if (!eggMesh) return;

    const centerX = container.clientWidth / 2;

    annotations.forEach(a => {
        if(!a.anchorObj) return;

        // --- 1. Get 3D Position ---
        a.anchorObj.getWorldPosition(tempVec);
        
        // --- 2. Occlusion Check ---
        const direction = tempVec.clone().sub(camera.position).normalize();
        const distToAnnotation = camera.position.distanceTo(tempVec);
        
        raycaster.set(camera.position, direction);
        const intersects = raycaster.intersectObject(eggMesh);

        let isVisible = true;
        if (intersects.length > 0) {
            // Tolerate small margin so dots don't flicker on edges
            if (intersects[0].distance < distToAnnotation - 0.2) { 
                isVisible = false;
            }
        }

        // If Active Annotation exists, hide all floating labels to reduce clutter
        if (activeAnnotation) isVisible = false;

        // --- 3. Update DOM Elements ---
        const screen = getScreenPos(tempVec);
        
        // Update Dot Position
        a.dotElement.style.left = screen.x + 'px';
        a.dotElement.style.top = screen.y + 'px';

        // Visibility Toggle
        if (isVisible && screen.z < 1 && screen.z > 0) {
            a.dotElement.style.opacity = 1;
            a.dotElement.style.pointerEvents = "auto";
            a.labelElement.style.opacity = 1;
            a.lineElement.style.opacity = 1;
        } else {
            a.dotElement.style.opacity = 0;
            a.dotElement.style.pointerEvents = "none";
            a.labelElement.style.opacity = 0;
            a.lineElement.style.opacity = 0;
            return; // Skip calculating lines if invisible
        }

        // --- 4. Engineering Drawing Logic (Left/Right Split) ---
        // Determine side based on screen position
        const isRight = screen.x > centerX;
        
        // Constants for the leader line
        const xOffset = isRight ? 80 : -80; // Distance of text from dot
        const yOffset = -40; // Lift text slightly up
        
        const labelX = screen.x + xOffset;
        const labelY = screen.y + yOffset;

        // Position Label
        a.labelElement.style.left = labelX + 'px';
        a.labelElement.style.top = labelY + 'px';
        
        // Adjust Label CSS to align text properly
        // If on right, text aligns left. If on left, text aligns right (towards egg).
        a.labelElement.style.transform = isRight ? "translate(0, -50%)" : "translate(-100%, -50%)";

        // Draw Line (Dot -> Label)
        // We calculate the end point of the line. 
        // If right side, line ends at left of text. If left side, line ends at right of text.
        const lineEndX = labelX;
        const lineEndY = labelY;

        a.lineElement.setAttribute("points", `${screen.x},${screen.y} ${lineEndX},${lineEndY}`);
    });

    // --- 5. Update Active Connector (The Big One) ---
    if (activeAnnotation && activeConnector.style.opacity > 0) {
        drawActiveConnector(activeAnnotation);
    }
}

function getScreenPos(v3) {
    const v = v3.clone();
    v.project(camera); 
    return {
        x: (v.x * 0.5 + 0.5) * container.clientWidth,
        y: (-(v.y) * 0.5 + 0.5) * container.clientHeight,
        z: v.z
    };
}

function drawActiveConnector(data) {
    data.anchorObj.getWorldPosition(tempVec);
    const start = getScreenPos(tempVec);
    
    // Aesthetic "Elbow" connector for the detail view
    const elbow = 50;
    const length = 60;
    const p1 = { x: start.x, y: start.y };
    const p2 = { x: start.x, y: start.y - elbow }; // Go Up
    
    // Determine direction for detail box
    const isRight = start.x > container.clientWidth / 2;
    const p3 = {
        x: isRight ? start.x + length : start.x - length,
        y: p2.y
    };

    activeConnector.setAttribute("points", `${p1.x},${p1.y} ${p2.x},${p2.y} ${p3.x},${p3.y}`);

    const textPad = 10;
    const offsetW = labelDiv.offsetWidth;
    
    labelDiv.style.left = isRight
        ? (p3.x + textPad) + "px" 
        : (p3.x - offsetW - textPad) + "px";
    labelDiv.style.top = (p3.y - 10) + "px";
}

window.addEventListener("resize", () => {
    camera.aspect = container.clientWidth / container.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(container.clientWidth, container.clientHeight);
});

animate();

</script>
    <script>
document.addEventListener('DOMContentLoaded', () => {
  const btn = document.getElementById('chirp-btn');
  const sound = document.getElementById('chirp-sound');
  const countDisplay = document.getElementById('chirp-count');
  
  // Local counter (Resets on refresh). 
  // To make this permanent later, we can connect a database service.
  let chirps = 0; 

  btn.addEventListener('click', () => {
    // 1. Play Sound
    if (sound) {
      sound.currentTime = 0; // Rewind to start so rapid clicks work
      sound.play().catch(e => console.log("Audio interaction needed first"));
    }

    // 2. Add Animation Class (Triggers CSS keyframes)
    btn.classList.add('chirping');

    // 3. Update the Counter Text
    chirps++;
    countDisplay.innerText = chirps + (chirps === 1 ? " chirp" : " chirps");

    // 4. Remove Animation Class after 1 second (stops the flapping)
    setTimeout(() => {
      btn.classList.remove('chirping');
    }, 1000); 
  });
});
    </script>
    
</body>
</html>
