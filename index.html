<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TerraDignus | The NestEgg</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&family=Playfair+Display:wght@400;600&display=swap');

        body {
            margin: 0;
            background-color: #ffffff;
            font-family: 'Roboto', sans-serif;
            overflow-x: hidden;
            color: #333;
        }

        /* --- HEADER --- */
        header {
            position: absolute;
            top: 40px;
            left: 40px;
            z-index: 10;
        }

        .brand-name {
            font-family: 'Roboto', sans-serif;
            font-weight: 700;
            font-size: 24px;
            color: #2C3E50;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* --- VIEWPORT & UI --- */
        #viewport {
            position: relative;
            width: 100%;
            height: 85vh;
            background: #ffffff;
            overflow: hidden;
            cursor: default;
        }

        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        /* Hotspots */
        .hotspot {
            position: absolute;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 2px solid #333;
            background: rgba(255,255,255,0.2);
            cursor: pointer;
            z-index: 10;
            transform: translate(-50%, -50%);
            transition: all 0.3s ease;
        }

        .hotspot:hover {
            transform: translate(-50%, -50%) scale(1.3);
            background-color: #333;
            border-color: #333;
        }

        /* Labels */
        .label-text {
            position: absolute;
            font-family: 'Times New Roman', serif;
            font-size: 18px;
            color: #000;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            z-index: 10;
            text-decoration: underline;
            text-underline-offset: 4px;
        }

        .desc-text {
            display: block;
            font-family: 'Roboto', sans-serif;
            font-size: 14px;
            color: #555;
            margin-top: 4px;
            text-decoration: none;
            max-width: 250px;
            white-space: normal;
            line-height: 1.4;
        }

        /* --- FOOTER --- */
        footer { width: 100%; }

        .footer-ip {
            background-color: #EBEBEB;
            padding: 50px 20px;
            text-align: center;
            color: #1a1a1a;
        }

        .footer-ip h3 {
            font-size: 20px;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .footer-ip p {
            font-size: 16px;
            margin: 0 0 25px 0;
            color: #444;
        }

        .patent-list {
            font-family: 'Courier New', monospace;
            font-size: 13px;
            color: #2F4F4F;
            line-height: 1.8;
        }

        .footer-brand {
            background-color: #080808;
            color: #ffffff;
            padding: 50px 20px;
            text-align: center;
        }

        .company-name {
            font-size: 18px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }

        .sub-brand {
            font-family: 'Playfair Display', serif;
            font-size: 16px;
            color: #ccc;
            margin-bottom: 25px;
        }

        .copyright {
            font-size: 12px;
            color: #666;
        }
    </style>
</head>
<body>

    <header>
        <div class="brand-name">TerraDignus</div>
    </header>

    <div id="viewport">
        <svg id="ui-layer">
            <polyline id="connector-line" points="" 
                      style="fill:none;stroke:black;stroke-width:1.5;opacity:0;transition:opacity 0.4s" />
        </svg>
        
        <div id="active-label" class="label-text">
            <span id="label-title">Title</span>
            <span id="label-desc" class="desc-text">Description goes here.</span>
        </div>
    </div>

    <footer>
        <div class="footer-ip">
            <h3>Intellectual Property Portfolio</h3>
            <p>Our technology is protected by pending United States Patents.</p>
            
            <div class="patent-list">
                <div>USPTO PATENT PENDING: Modular Wildlife Habitation System</div>
                <div>USPTO PATENT PENDING: In-Situ Monolithic Composite System</div>
                <div>USPTO PATENT PENDING: Variable-Volume Wildlife Habitation System</div>
            </div>
        </div>

        <div class="footer-brand">
            <div class="company-name">PERDIGNUS LLC</div>
            <div class="sub-brand">TerraDignus™ | NecTerra</div>
            <div class="copyright">© MMXXV Nicholas J. Law. All Rights Reserved.</div>
        </div>
    </footer>

    <script>
        // --- 1. SCENE SETUP ---
        const container = document.getElementById('viewport');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 100);
        // "Home" view position
        const homePos = { x: 0, y: 0.5, z: 9 };
        camera.position.set(homePos.x, homePos.y, homePos.z);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // --- 2. LIGHTING (Soft Studio) ---
        const ambLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambLight);

        const keyLight = new THREE.DirectionalLight(0xffffff, 0.8);
        keyLight.position.set(5, 8, 5);
        keyLight.castShadow = true;
        keyLight.shadow.mapSize.width = 1024;
        keyLight.shadow.mapSize.height = 1024;
        scene.add(keyLight);

        const fillLight = new THREE.DirectionalLight(0xffecd2, 0.3);
        fillLight.position.set(-5, 2, 5);
        scene.add(fillLight);

        // --- 3. LOAD REAL NESTEGG .GLB MODEL ---
const nestEggGroup = new THREE.Group();
scene.add(nestEggGroup);

const loader = new THREE.GLTFLoader();

loader.load(
    "assets/NestEggFBCR.glb",
    function (gltf) {
        const model = gltf.scene;

        // OPTIONAL — Adjust scale to look right in camera
        model.scale.set(1.5, 1.5, 1.5);

        // Center the model properly
        const box = new THREE.Box3().setFromObject(model);
        const center = box.getCenter(new THREE.Vector3());
        model.position.sub(center);

        nestEggGroup.add(model);
    },
    undefined,
    function (error) {
        console.error("GLTF LOAD ERROR:", error);
    }
);


        // --- 4. CONTROLS ---
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enableZoom = false; // LOCKED ZOOM
        controls.enablePan = false;
        controls.rotateSpeed = 0.3; // SLOW ROTATION
        controls.minPolarAngle = Math.PI / 4; // Limit vertical rotation
        controls.maxPolarAngle = Math.PI - Math.PI / 4;

        // --- 5. ANNOTATION DATA (Updated Positions) ---
        const annotations = [
            {
                id: 1,
                title: "Ventilation Aperture",
                desc: "Passive thermal regulation vent.",
                // Positioned high on the right shoulder (Label 4)
                pos: new THREE.Vector3(0.8, 1.2, 0.9), 
                camPos: { x: 3, y: 1.5, z: 4 },
                lineDir: "right"
            },
            {
                id: 2,
                title: "Ingress Tunnel",
                desc: "Predator-resistant entry geometry.",
                // Positioned on the snout (Label 3)
                pos: new THREE.Vector3(-1.1, 0.9, 0.9), 
                camPos: { x: -3, y: 1, z: 4 },
                lineDir: "left"
            },
            {
                id: 3,
                title: "Basal Hemisphere",
                desc: "Impact-resistant composite shell.",
                // Positioned low on the belly (Label 17)
                pos: new THREE.Vector3(0, -1.0, 1.4), 
                camPos: { x: 0, y: -2, z: 5 },
                lineDir: "right"
            }
        ];

        // --- 6. INTERACTION LOGIC ---
        const uiLayer = document.getElementById('ui-layer');
        const connectorLine = document.getElementById('connector-line');
        const labelDiv = document.getElementById('active-label');
        const labelTitle = document.getElementById('label-title');
        const labelDesc = document.getElementById('label-desc');
        let activeAnnotation = null;

        // Create HTML Hotspots
        annotations.forEach(data => {
            const div = document.createElement('div');
            div.className = 'hotspot';
            div.addEventListener('click', (e) => {
                e.stopPropagation(); // Stop click from hitting background
                activateAnnotation(data);
            });
            container.appendChild(div);
            data.element = div;
        });

        function activateAnnotation(data) {
            activeAnnotation = data;

            // 1. Move Camera (Zoom In)
            gsap.to(camera.position, {
                duration: 1.5,
                x: data.camPos.x,
                y: data.camPos.y,
                z: data.camPos.z,
                ease: "power2.inOut"
            });

            // 2. Update Text
            labelTitle.innerText = data.title;
            labelDesc.innerText = data.desc;

            // 3. Reveal UI (Delayed for camera move)
            setTimeout(() => {
                if(activeAnnotation === data) { // Check if still active
                    labelDiv.style.opacity = 1;
                    connectorLine.style.opacity = 1;
                }
            }, 800);
        }

        function resetView() {
            if(!activeAnnotation) return;
            activeAnnotation = null;

            // Hide UI
            labelDiv.style.opacity = 0;
            connectorLine.style.opacity = 0;

            // Reset Camera (Zoom Out)
            gsap.to(camera.position, {
                duration: 1.5,
                x: homePos.x,
                y: homePos.y,
                z: homePos.z,
                ease: "power2.inOut"
            });
        }

        // Background Click -> Reset
        container.addEventListener('click', resetView);

        // --- 7. RENDER LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // Rotate model slowly if idle? (Optional, disabled for engineering feel)
            // nestEggGroup.rotation.y += 0.001; 

            renderer.render(scene, camera);

            // Update Hotspot Positions
            annotations.forEach(data => {
                const screenPos = getScreenPos(data.pos);
                
                // Simple Occlusion Check (is point behind the object?)
                // We use distance to camera roughly
                const dist = camera.position.distanceTo(data.pos);
                // If it's on the back side of sphere, hide it (Dot Product method is better but this is simple)
                // For this specific setup, we just hide if Z is too far back relative to view
                
                // Update CSS position
                data.element.style.left = screenPos.x + 'px';
                data.element.style.top = screenPos.y + 'px';

                // Rough visibility check (simple z-index hiding)
                if (screenPos.z > 1 || screenPos.z < 0) {
                     data.element.style.opacity = 0;
                     data.element.style.pointerEvents = 'none';
                } else {
                     data.element.style.opacity = 1;
                     data.element.style.pointerEvents = 'auto';
                }
            });

            // Draw Connector Line
            if (activeAnnotation && connectorLine.style.opacity > 0) {
                drawConnector(activeAnnotation);
            }
        }

        function getScreenPos(vector3) {
            // Must clone because project changes the vector
            const v = vector3.clone();
            // We need to account for the Group rotation if we rotated the group
            // But here we didn't rotate the group, only added children
            v.project(camera);

            const x = (v.x * 0.5 + 0.5) * container.clientWidth;
            const y = (-(v.y) * 0.5 + 0.5) * container.clientHeight;
            return { x, y, z: v.z };
        }

        function drawConnector(data) {
            const start = getScreenPos(data.pos);
            const lineLength = 60;
            const elbowHeight = 50;

            let p1, p2, p3;

            // Engineering "Elbow" Style:
            // Point 1: At the hotspot
            // Point 2: Up/Down vertical offset
            // Point 3: Left/Right horizontal to text
            
            p1 = { x: start.x, y: start.y };
            p2 = { x: start.x, y: start.y - elbowHeight }; // Go Up
            p3 = { x: (data.lineDir === 'right' ? start.x + lineLength : start.x - lineLength), y: p2.y }; // Go Sideways

            // Update SVG Polyline
            connectorLine.setAttribute('points', `${p1.x},${p1.y} ${p2.x},${p2.y} ${p3.x},${p3.y}`);

            // Position Text at end of line
            const textPad = 10;
            if (data.lineDir === 'right') {
                labelDiv.style.left = (p3.x + textPad) + 'px';
            } else {
                labelDiv.style.left = (p3.x - labelDiv.offsetWidth - textPad) + 'px';
            }
            labelDiv.style.top = (p3.y - 10) + 'px'; // Sit on the line
        }

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });

        animate();
    </script>
</body>
</html>
