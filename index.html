<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TerraDignus | Engineering Detail</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&family=Playfair+Display:wght@400;600&display=swap');

        body {
            margin: 0;
            background-color: #ffffff;
            font-family: 'Roboto', sans-serif;
            overflow-x: hidden;
            color: #333;
        }

        /* --- HEADER (MATCHING VIDEO) --- */
        header {
            position: absolute;
            top: 40px;
            left: 40px;
            z-index: 10;
        }

        .brand-name {
            font-family: 'Roboto', sans-serif;
            font-weight: 700;
            font-size: 24px;
            color: #2C3E50; /* Dark Slate Blue/Grey */
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* --- MAIN CONTENT --- */
        #viewport {
            position: relative;
            width: 100%;
            height: 85vh;
            background: #ffffff;
            overflow: hidden;
        }

        /* SVG Overlay for Engineering Lines */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through to 3D canvas */
            z-index: 5;
        }

        /* Hotspots (Clickable dots) */
        .hotspot {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #333; /* Engineering style ring */
            cursor: pointer;
            z-index: 10;
            transform: translate(-50%, -50%);
            transition: transform 0.2s, background-color 0.2s;
        }

        .hotspot:hover {
            transform: translate(-50%, -50%) scale(1.3);
            background-color: rgba(0,0,0,0.1);
        }

        /* Labels (Hidden by default) */
        .label-text {
            position: absolute;
            font-family: 'Times New Roman', serif; /* Engineering drawing font style */
            font-size: 18px;
            color: #000;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            z-index: 10;
            text-decoration: underline;
            text-underline-offset: 4px;
        }

        /* --- FOOTER (MATCHING SCREENSHOT) --- */
        footer {
            width: 100%;
        }

        /* Top Footer Section (Grey) */
        .footer-ip {
            background-color: #EBEBEB; /* Light Grey */
            padding: 60px 20px;
            text-align: center;
            color: #1a1a1a;
        }

        .footer-ip h3 {
            font-size: 22px;
            margin-bottom: 15px;
            font-weight: 700;
        }

        .footer-ip p {
            font-size: 16px;
            margin: 5px 0;
            line-height: 1.5;
        }

        .patent-list {
            margin-top: 30px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #2F4F4F; /* Dark Slate Greenish hue from image */
        }

        .patent-item {
            margin: 8px 0;
            letter-spacing: 0.5px;
        }

        /* Bottom Footer Section (Black) */
        .footer-brand {
            background-color: #080808; /* Near Black */
            color: #ffffff;
            padding: 60px 20px;
            text-align: center;
        }

        .company-name {
            font-size: 20px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 15px;
        }

        .sub-brand {
            font-family: 'Playfair Display', serif;
            font-size: 18px;
            color: #ccc;
            margin-bottom: 30px;
        }

        .copyright {
            font-size: 12px;
            color: #666;
            margin-top: 20px;
        }

    </style>
</head>
<body>

    <header>
        <div class="brand-name">TerraDignus</div>
    </header>

    <div id="viewport">
        <svg id="ui-layer">
            <polyline id="connector-line" points="" style="fill:none;stroke:black;stroke-width:2;opacity:0;transition:opacity 0.5s" />
        </svg>
        
        <div id="active-label" class="label-text">Detailed Description</div>
    </div>

    <footer>
        <div class="footer-ip">
            <h3>Intellectual Property Portfolio</h3>
            <p>Our technology is protected by pending United States Patents.</p>
            
            <div class="patent-list">
                <div class="patent-item">USPTO PATENT PENDING: Modular Wildlife Habitation System</div>
                <div class="patent-item">USPTO PATENT PENDING: In-Situ Monolithic Composite System</div>
                <div class="patent-item">USPTO PATENT PENDING: Variable-Volume Wildlife Habitation System</div>
            </div>
        </div>

        <div class="footer-brand">
            <div class="company-name">PERDIGNUS LLC</div>
            <div class="sub-brand">TerraDignus™ | NecTerra</div>
            <div class="copyright">© MMXXV Nicholas J. Law. All Rights Reserved.</div>
        </div>
    </footer>

    <script>
        // --- SCENE SETUP ---
        const container = document.getElementById('viewport');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 100);
        const initialCamPos = { x: 0, y: 0, z: 9 }; // Front view initially
        camera.position.set(initialCamPos.x, initialCamPos.y, initialCamPos.z);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        // Enable shadows for that realistic look
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // --- LIGHTING (Studio Setup for "Clay" Look) ---
        const ambLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambLight);

        const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
        mainLight.position.set(5, 5, 5);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = 1024;
        mainLight.shadow.mapSize.height = 1024;
        scene.add(mainLight);

        const fillLight = new THREE.DirectionalLight(0xffecd2, 0.4); // Warm fill
        fillLight.position.set(-5, 0, 5);
        scene.add(fillLight);

        // --- CONTROLS ---
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enableZoom = false; // DISABLED AS REQUESTED
        controls.enablePan = false;
        controls.rotateSpeed = 0.3; // SLOW ROTATION
        
        // --- MODEL (The Egg) ---
        // Creating a shape that matches the screenshot (wider bottom, tapered top)
        const points = [];
        for (let i = 0; i <= 30; i++) {
            const t = i / 30;
            // Custom egg curve formula
            const y = (t * 4) - 2; 
            const x = Math.sin(t * Math.PI) * (1.5 - (t * 0.3)); 
            points.push(new THREE.Vector2(x, y));
        }
        
        const geo = new THREE.LatheGeometry(points, 64);
        
        // Material: Clay/Beige (Matching image_032f9b.jpg)
        const mat = new THREE.MeshStandardMaterial({
            color: 0xC6B89D, // Beige/Tan
            roughness: 0.7,  // Matte finish
            metalness: 0.1
        });

        const egg = new THREE.Mesh(geo, mat);
        egg.castShadow = true;
        egg.receiveShadow = true;
        scene.add(egg);

        // --- THE ENTRY HOLE (Visual Trickery) ---
        // Placing a dark circle to simulate the hole shown in drawing/render label '3'
        const holeGeo = new THREE.CircleGeometry(0.5, 32);
        const holeMat = new THREE.MeshBasicMaterial({ color: 0x2b2b2b }); // Dark Grey/Black
        const hole = new THREE.Mesh(holeGeo, holeMat);
        // Positioned based on label 3 in your drawing (mid-upper left)
        hole.position.set(-0.95, 0.5, 1.0); 
        hole.lookAt(-2, 0.8, 3); // Angle it slightly
        egg.add(hole);

        // --- ANNOTATION DATA ---
        // Positions based on your 2D drawing (image_033f9a.png)
        const annotations = [
            {
                id: 1,
                label: "Ventilation Aperture",
                pos: new THREE.Vector3(0.6, 1.2, 1.0), // Label 4
                camPos: { x: 3, y: 1.5, z: 3 }, // Zoom angle
                lineDir: "right" // Draw line to the right
            },
            {
                id: 2,
                label: "Ingress Aperture",
                pos: new THREE.Vector3(-0.8, 0.5, 1.1), // Label 3
                camPos: { x: -3, y: 0.5, z: 3 },
                lineDir: "left"
            },
            {
                id: 3,
                label: "Basal Hemisphere",
                pos: new THREE.Vector3(1.1, -1.0, 0.5), // Label 17
                camPos: { x: 3, y: -1, z: 4 },
                lineDir: "right"
            }
        ];

        // --- UI LOGIC ---
        const uiLayer = document.getElementById('ui-layer');
        const connectorLine = document.getElementById('connector-line');
        const labelDiv = document.getElementById('active-label');
        let activeAnnotation = null;

        // Create Hotspots
        annotations.forEach(data => {
            const div = document.createElement('div');
            div.className = 'hotspot';
            div.dataset.id = data.id;
            div.addEventListener('click', (e) => {
                e.stopPropagation();
                zoomTo(data);
            });
            container.appendChild(div);
            data.element = div; // Store reference
        });

        function zoomTo(data) {
            activeAnnotation = data;
            
            // 1. Animate Camera
            gsap.to(camera.position, {
                duration: 1.5,
                x: data.camPos.x,
                y: data.camPos.y,
                z: data.camPos.z,
                ease: "power2.inOut"
            });
            
            // 2. Show UI Elements after delay
            setTimeout(() => {
                labelDiv.innerText = data.label;
                labelDiv.style.opacity = 1;
                connectorLine.style.opacity = 1;
            }, 1000);
        }

        function resetView() {
            if(!activeAnnotation) return;
            activeAnnotation = null;

            // Hide UI
            labelDiv.style.opacity = 0;
            connectorLine.style.opacity = 0;

            // Reset Camera
            gsap.to(camera.position, {
                duration: 1.5,
                x: initialCamPos.x,
                y: initialCamPos.y,
                z: initialCamPos.z,
                ease: "power2.inOut"
            });
        }

        // Global Click to Reset
        container.addEventListener('click', resetView);

        // --- UPDATE LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);

            // Update Hotspot Positions
            annotations.forEach(data => {
                const screenPos = getScreenPos(data.pos);
                
                // Hide if behind model
                if(screenPos.z > 1) {
                    data.element.style.display = 'none';
                } else {
                    data.element.style.display = 'block';
                    data.element.style.left = screenPos.x + 'px';
                    data.element.style.top = screenPos.y + 'px';
                }
            });

            // Draw Engineering Line if active
            if (activeAnnotation && connectorLine.style.opacity > 0) {
                drawConnector(activeAnnotation);
            }
        }

        function getScreenPos(vector3) {
            const v = vector3.clone();
            v.project(camera);
            const x = (v.x * 0.5 + 0.5) * container.clientWidth;
            const y = (-(v.y) * 0.5 + 0.5) * container.clientHeight;
            return { x, y, z: v.z };
        }

        function drawConnector(data) {
            const start = getScreenPos(data.pos);
            
            // Define engineering line shape: Start -> Up/Out -> Elbow -> Text
            // Hardcoded "Elbow" offsets for that technical look
            const elbowX = data.lineDir === "right" ? start.x + 50 : start.x - 50;
            const elbowY = start.y - 50;
            const endX = data.lineDir === "right" ? elbowX + 100 : elbowX - 100;
            
            // Update SVG Line
            // Points: Start -> Elbow -> End
            const pointsString = `${start.x},${start.y} ${elbowX},${start.y} ${elbowX},${elbowY} ${endX},${elbowY}`;
            
            // Use simple 2-point line for cleaner look if preferred, but doing 3-point for "Tech" feel
            // Let's match the screenshot style: Straight line out, then horizontal text
            // Screenshot shows: Dot -> Straight Line -> Text
            const textPad = 10;
            
            // Screenshot logic: Horizontal line to text
            const lineEndX = data.lineDir === "right" ? start.x + 100 : start.x - 100;
            const lineEndY = start.y; // Straight horizontal
            
            // Let's do the "Elbow" shown in drawing: Up and Over
            connectorLine.setAttribute('points', `${start.x},${start.y} ${elbowX},${start.y} ${elbowX},${elbowY} ${endX},${elbowY}`);

            // Position Label at end of line
            labelDiv.style.left = (data.lineDir === "right" ? endX + textPad : endX - labelDiv.offsetWidth - textPad) + 'px';
            labelDiv.style.top = (elbowY - 10) + 'px'; // Sits on top of the line
        }

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });

        animate();
    </script>
</body>
</html>
