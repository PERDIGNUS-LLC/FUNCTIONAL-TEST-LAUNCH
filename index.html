<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TerraDignus | The NestEgg</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <style>
        :root {
            --primary: #2C3E50;
            --text: #222;
            --bg: #ffffff;
        }

        body {
            margin: 0;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            overflow-x: hidden; /* Prevent horizontal scroll */
        }

        /* --- REVERTED HEADER STYLE --- */
        nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 2rem 4rem;
            background: transparent;
            position: absolute;
            width: 100%;
            top: 0;
            z-index: 10;
            box-sizing: border-box;
        }

        .logo {
            font-size: 1.8rem;
            font-weight: 700;
            letter-spacing: -1px;
            color: var(--primary);
            text-transform: uppercase;
        }

        /* --- 3D CANVAS & UI --- */
        #canvas-wrapper {
            position: relative;
            width: 100%;
            height: 90vh; /* Taller view */
            background: #ffffff;
            cursor: default;
        }

        /* Floating Text (No Boxes) */
        .floating-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(20px, -50%); /* Offset slightly from center */
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease;
            text-align: left;
            max-width: 300px;
        }

        .floating-label h2 {
            font-size: 1.5rem;
            margin: 0 0 0.5rem 0;
            font-weight: 600;
            color: #000;
        }

        .floating-label p {
            font-size: 1rem;
            line-height: 1.4;
            color: #444;
            margin: 0;
        }

        /* The dots on the model */
        .annotation-marker {
            position: absolute;
            width: 16px;
            height: 16px;
            background: transparent; 
            border: 2px solid #000; /* Engineering style circle */
            border-radius: 50%;
            cursor: pointer;
            z-index: 100;
            transform: translate(-50%, -50%);
            transition: transform 0.2s;
        }

        .annotation-marker:hover {
            background: #000;
            transform: translate(-50%, -50%) scale(1.2);
        }

        /* Footer */
        footer {
            background: #fff;
            color: #444;
            padding: 4rem 2rem;
            text-align: center;
            border-top: 1px solid #eee;
        }

        .patent-number {
            font-family: 'Courier New', monospace;
            font-size: 0.75rem;
            color: #666;
            margin: 0.4rem 0;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
    </style>
</head>
<body>

    <nav>
        <div class="logo">TerraDignus</div>
    </nav>

    <div id="canvas-wrapper">
        <div id="floating-text" class="floating-label">
            <h2 id="ft-title"></h2>
            <p id="ft-desc"></p>
        </div>
    </div>

    <footer>
        <div id="patent-info">
            <p class="patent-number">USPTO PATENT PENDING: Modular Wildlife Habitation System</p>
            <p class="patent-number">USPTO PATENT PENDING: In-Situ Monolithic Composite System</p>
            <p class="patent-number">USPTO PATENT PENDING: Variable-Volume Wildlife Habitation System</p>
        </div>
    </footer>

    <script>
        // --- CONFIGURATION ---
        const sceneConfig = {
            bg: 0xffffff,
            lineColor: 0x000000,
            modelColor: 0xffffff,
            animSpeed: 1.5 // Speed of zoom
        };

        // --- SETUP ---
        const container = document.getElementById('canvas-wrapper');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(sceneConfig.bg);

        const camera = new THREE.PerspectiveCamera(40, container.clientWidth / container.clientHeight, 0.1, 100);
        
        // Initial Engineering View (Isometric-ish)
        const homePos = { x: 8, y: 4, z: 8 }; 
        const homeTarget = { x: 0, y: 0.5, z: 0 };
        camera.position.set(homePos.x, homePos.y, homePos.z);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Sharp lines
        container.appendChild(renderer.domElement);

        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.enableZoom = false; // DISABLED AS REQUESTED
        controls.enablePan = false;
        controls.rotateSpeed = 0.3; // SLOWED DOWN AS REQUESTED
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // Lighting (Flat, technical lighting)
        const ambLight = new THREE.AmbientLight(0xffffff, 0.9);
        scene.add(ambLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.3);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);

        // --- THE NESTEGG MODEL (Procedural Generation) ---
        // Creating an Egg shape using LatheGeometry to match your drawing profile
        const points = [];
        for ( let i = 0; i <= 20; i ++ ) {
            // Using a sine curve logic to approximate the egg profile (narrow top, wide bottom)
            const t = i / 20;
            const y = (t * 4.5) - 2.25; // Height scaling
            const x = Math.sin(t * Math.PI) * (1.6 - (t * 0.4)); // Width scaling with taper
            points.push( new THREE.Vector2( x, y ) );
        }
        const geometry = new THREE.LatheGeometry( points, 64 );
        
        // Material: Matte White + "Sketch" Edges
        const material = new THREE.MeshBasicMaterial({ 
            color: 0xffffff,
            polygonOffset: true,
            polygonOffsetFactor: 1, 
            polygonOffsetUnits: 1
        });
        const mesh = new THREE.Mesh( geometry, material );
        scene.add( mesh );

        // Add Wireframe/Edges for Engineering Look
        const edges = new THREE.EdgesGeometry( geometry, 15 ); // Threshold angle
        const line = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { color: 0x000000, linewidth: 2 } ) );
        scene.add( line );

        // Simulate the HOLE (Label 3) visually with a black circle
        // We can't easily cut a hole in vanilla ThreeJS w/o CSG, so we place a dark "cap"
        const holeGeo = new THREE.CircleGeometry(0.5, 32);
        const holeMat = new THREE.MeshBasicMaterial({ color: 0x222222 });
        const holeMesh = new THREE.Mesh(holeGeo, holeMat);
        // Position roughly where Label 3 is
        holeMesh.position.set(0.9, 0.8, 0.8); 
        holeMesh.lookAt(2, 1.5, 2); // Angle it towards the surface normal approx
        scene.add(holeMesh);


        // --- ANNOTATIONS SYSTEM ---
        
        // Coordinates mapped roughly to your image labels
        const annotations = [
            {
                id: '21',
                label: "21",
                title: "Upper Housing",
                desc: "Impact-resistant monolithic shell structure.",
                pos: new THREE.Vector3(0, 2.1, 0), // Top of dome
                camPos: { x: 0, y: 3, z: 4 }
            },
            {
                id: '3',
                label: "3",
                title: "Ingress Aperture",
                desc: "Precision-calibrated entry point for target species.",
                pos: new THREE.Vector3(0.9, 0.8, 0.8), // The Hole location
                camPos: { x: 2, y: 1, z: 2 }
            },
            {
                id: '4',
                label: "4",
                title: "Ventilation Port",
                desc: "Secondary airflow channel for thermal regulation.",
                pos: new THREE.Vector3(0.6, 1.5, 1.0), // High up, offset (Small hole)
                camPos: { x: 1.5, y: 1.8, z: 2.5 }
            },
            {
                id: '17',
                label: "17",
                title: "Basal Hemisphere",
                desc: "Structural foundation with integrated drainage.",
                pos: new THREE.Vector3(1.2, -1.0, 0), // Bottom curve
                camPos: { x: 3, y: -1.5, z: 1 }
            }
        ];

        // Create DOM Elements for markers
        const markers = [];
        annotations.forEach(data => {
            const el = document.createElement('div');
            el.className = 'annotation-marker';
            el.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent background click
                activateAnnotation(data);
            });
            container.appendChild(el);
            markers.push({ el, ...data });
        });

        const textContainer = document.getElementById('floating-text');
        const titleEl = document.getElementById('ft-title');
        const descEl = document.getElementById('ft-desc');
        let isZoomed = false;

        // --- INTERACTION LOGIC ---

        function activateAnnotation(data) {
            isZoomed = true;
            controls.autoRotate = false; // Stop spinning

            // 1. Move Camera
            gsap.to(camera.position, {
                duration: sceneConfig.animSpeed,
                x: data.camPos.x,
                y: data.camPos.y,
                z: data.camPos.z,
                ease: "power2.inOut"
            });

            // 2. Focus Target
            gsap.to(controls.target, {
                duration: sceneConfig.animSpeed,
                x: data.pos.x,
                y: data.pos.y,
                z: data.pos.z,
                ease: "power2.inOut",
                onUpdate: () => controls.update()
            });

            // 3. Update & Show Text (Floating, no box)
            titleEl.innerText = `${data.label}. ${data.title}`;
            descEl.innerText = data.desc;
            
            // Calculate screen position for text offset
            // We just center it for now, user asked for floating aesthetic
            // Simple fade in
            textContainer.style.opacity = 0;
            setTimeout(() => {
                textContainer.style.opacity = 1;
            }, 500);
        }

        // RESET FUNCTION (Background Click)
        container.addEventListener('click', () => {
            if (!isZoomed) return;
            isZoomed = false;
            controls.autoRotate = true;

            // Fade out text
            textContainer.style.opacity = 0;

            // Reset Camera
            gsap.to(camera.position, {
                duration: sceneConfig.animSpeed,
                x: homePos.x,
                y: homePos.y,
                z: homePos.z,
                ease: "power2.inOut"
            });

            // Reset Target
            gsap.to(controls.target, {
                duration: sceneConfig.animSpeed,
                x: homeTarget.x,
                y: homeTarget.y,
                z: homeTarget.z,
                ease: "power2.inOut",
                onUpdate: () => controls.update()
            });
        });

        // --- RENDER LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // Sync Marker Positions
            markers.forEach(m => {
                // Get 2D screen position
                const vector = m.pos.clone();
                vector.project(camera);

                // Convert to CSS coords
                const x = (vector.x * 0.5 + 0.5) * container.clientWidth;
                const y = (-(vector.y) * 0.5 + 0.5) * container.clientHeight;

                m.el.style.left = `${x}px`;
                m.el.style.top = `${y}px`;

                // Hide if behind model (simple Z check)
                // For a proper check we'd use Raycasting, but this saves perf
                if (vector.z > 0.98) { // Clipping plane roughly
                    m.el.style.opacity = 0;
                    m.el.style.pointerEvents = 'none';
                } else {
                    m.el.style.opacity = 1;
                    m.el.style.pointerEvents = 'auto';
                }
            });

            renderer.render(scene, camera);
        }

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });

        animate();

    </script>
</body>
</html>
